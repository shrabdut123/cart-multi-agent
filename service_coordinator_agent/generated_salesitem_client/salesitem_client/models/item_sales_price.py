# coding: utf-8

"""
    Sales Item API

    Get information for items in different contexts. Note that this is an extendable interface that might introduce new types without increase in major version including new values in enumerations. 

    The version of the OpenAPI document: 1.45.0
    Contact: paul.eriksson@ingka.ikea.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from salesitem_client.models.advertisement import Advertisement
from salesitem_client.models.class_unit_key import ClassUnitKey
from salesitem_client.models.fee import Fee
from salesitem_client.models.item_key import ItemKey
from salesitem_client.models.price_attribute import PriceAttribute
from salesitem_client.models.price_unit import PriceUnit
from salesitem_client.models.sales_price import SalesPrice
from salesitem_client.models.service_price import ServicePrice
from typing import Optional, Set
from typing_extensions import Self

class ItemSalesPrice(BaseModel):
    """
    ItemSalesPrice
    """ # noqa: E501
    advertisements: Optional[List[Advertisement]] = None
    class_unit_key: Optional[ClassUnitKey] = Field(default=None, alias="classUnitKey")
    currency_rank: Optional[Annotated[List[StrictStr], Field(min_length=1)]] = Field(default=None, description="Sorted list of currencies. In most cases it will only have one entry.  In the case that there are multiple entries, the order dictates the priority.  For example, the order that the currencies should be presented towards customers. Meaning that the first entry has the highest priority.", alias="currencyRank")
    fees: Optional[List[Fee]] = None
    is_unit_price_preferred: Optional[StrictBool] = Field(default=None, alias="isUnitPricePreferred")
    item_key: Optional[ItemKey] = Field(default=None, alias="itemKey")
    price_attributes: Optional[List[PriceAttribute]] = Field(default=None, description="Additional attributes that are used in the communication of sales price. Only to be used for specific purpose information meaning used only by some touchpoints or channels, used only in specific scenarios, used only in specific markets for legal reasons or as a short term exception that will be resolved in the next version. FreeOfFreight enum should only be used for STO requests and is only temporarily exposed for RU requests for testing purposes and could be removed in the future.", alias="priceAttributes")
    price_unit: Optional[PriceUnit] = Field(default=None, alias="priceUnit")
    sales_prices: Optional[List[SalesPrice]] = Field(default=None, alias="salesPrices")
    service_prices: Optional[List[ServicePrice]] = Field(default=None, alias="servicePrices")
    update_date_time: Optional[datetime] = Field(default=None, alias="updateDateTime")
    __properties: ClassVar[List[str]] = ["advertisements", "classUnitKey", "currencyRank", "fees", "isUnitPricePreferred", "itemKey", "priceAttributes", "priceUnit", "salesPrices", "servicePrices", "updateDateTime"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ItemSalesPrice from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in advertisements (list)
        _items = []
        if self.advertisements:
            for _item_advertisements in self.advertisements:
                if _item_advertisements:
                    _items.append(_item_advertisements.to_dict())
            _dict['advertisements'] = _items
        # override the default output from pydantic by calling `to_dict()` of class_unit_key
        if self.class_unit_key:
            _dict['classUnitKey'] = self.class_unit_key.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in fees (list)
        _items = []
        if self.fees:
            for _item_fees in self.fees:
                if _item_fees:
                    _items.append(_item_fees.to_dict())
            _dict['fees'] = _items
        # override the default output from pydantic by calling `to_dict()` of item_key
        if self.item_key:
            _dict['itemKey'] = self.item_key.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in price_attributes (list)
        _items = []
        if self.price_attributes:
            for _item_price_attributes in self.price_attributes:
                if _item_price_attributes:
                    _items.append(_item_price_attributes.to_dict())
            _dict['priceAttributes'] = _items
        # override the default output from pydantic by calling `to_dict()` of price_unit
        if self.price_unit:
            _dict['priceUnit'] = self.price_unit.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in sales_prices (list)
        _items = []
        if self.sales_prices:
            for _item_sales_prices in self.sales_prices:
                if _item_sales_prices:
                    _items.append(_item_sales_prices.to_dict())
            _dict['salesPrices'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in service_prices (list)
        _items = []
        if self.service_prices:
            for _item_service_prices in self.service_prices:
                if _item_service_prices:
                    _items.append(_item_service_prices.to_dict())
            _dict['servicePrices'] = _items
        # set to None if advertisements (nullable) is None
        # and model_fields_set contains the field
        if self.advertisements is None and "advertisements" in self.model_fields_set:
            _dict['advertisements'] = None

        # set to None if fees (nullable) is None
        # and model_fields_set contains the field
        if self.fees is None and "fees" in self.model_fields_set:
            _dict['fees'] = None

        # set to None if price_attributes (nullable) is None
        # and model_fields_set contains the field
        if self.price_attributes is None and "price_attributes" in self.model_fields_set:
            _dict['priceAttributes'] = None

        # set to None if price_unit (nullable) is None
        # and model_fields_set contains the field
        if self.price_unit is None and "price_unit" in self.model_fields_set:
            _dict['priceUnit'] = None

        # set to None if sales_prices (nullable) is None
        # and model_fields_set contains the field
        if self.sales_prices is None and "sales_prices" in self.model_fields_set:
            _dict['salesPrices'] = None

        # set to None if service_prices (nullable) is None
        # and model_fields_set contains the field
        if self.service_prices is None and "service_prices" in self.model_fields_set:
            _dict['servicePrices'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ItemSalesPrice from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "advertisements": [Advertisement.from_dict(_item) for _item in obj["advertisements"]] if obj.get("advertisements") is not None else None,
            "classUnitKey": ClassUnitKey.from_dict(obj["classUnitKey"]) if obj.get("classUnitKey") is not None else None,
            "currencyRank": obj.get("currencyRank"),
            "fees": [Fee.from_dict(_item) for _item in obj["fees"]] if obj.get("fees") is not None else None,
            "isUnitPricePreferred": obj.get("isUnitPricePreferred"),
            "itemKey": ItemKey.from_dict(obj["itemKey"]) if obj.get("itemKey") is not None else None,
            "priceAttributes": [PriceAttribute.from_dict(_item) for _item in obj["priceAttributes"]] if obj.get("priceAttributes") is not None else None,
            "priceUnit": PriceUnit.from_dict(obj["priceUnit"]) if obj.get("priceUnit") is not None else None,
            "salesPrices": [SalesPrice.from_dict(_item) for _item in obj["salesPrices"]] if obj.get("salesPrices") is not None else None,
            "servicePrices": [ServicePrice.from_dict(_item) for _item in obj["servicePrices"]] if obj.get("servicePrices") is not None else None,
            "updateDateTime": obj.get("updateDateTime")
        })
        return _obj


